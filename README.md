# 알고리즘 기초
## Considering Time / Space Complexity
모든 코테 문제는 시간 제한 / 메모리 제한이 존재 (묵시적으로 1 ~ 5초 , 128 ~ 512 MB)

- ### 시간 복잡도 : **입력에 크기**와 **문제 해결에 걸리는 시간**의 **비례관계**  

- 시간 복잡도 예시
> 일렬로 나열된 N 명의 사람 중 이름이 "이흥직"인 사람을 찾는 시간은 N에 비례한다
> <br>=> 시간복잡도 : O(N)

> 이름순으로 정렬된 N 명의 사람 중 이름이 "이흥직"인 사람을 찾는 시간은  log N 에 비례한다
> <BR> => 시간 복잡도 : O(logN) ,  N / 2 로 나눠서 이름을 물어봄
- 수학에서는 밑이 생략된 log는 밑이 10이지만, 컴퓨터 과학에서는 2이다.

---

- ### 공간 복잡도 : **입력에 크기**와 **문제 해결에 필요한 메모리 양**의 **비례관계**
    - 코딩 테스트에서는 공간 복잡도에 의해 틀릴 일이 거의 없을 것
    - **512MB** 가 **int 변수 1.34 억** , **Integer 변수가 2200 만** 개 저장 가능

---
- ### 시간복잡도에 따른 입력 N의 최대 크기

컴퓨터는 1초에 약 1억(10^8)번의 연산을 할 수 있음
- CPU마다 다르지만, 코딩 테스트에서는 기준이 되는 CPU를 사용
<BR><BR>
하지만 현실에서 코드가 돌아갈 때는 순수한 연산만 있는 게 아니기 때문에 아래를 참고

| 입력 N의 크기       | 허용 시간복잡도       |
|----------------|------------------------|
| N ≤ 11         | O(N!)                  |
| N ≤ 20         | O(2^N)                 |
| N ≤ 100        | O(N⁴)                  |
| N ≤ 500        | O(N³)                  |
| N ≤ 3,000      | O(N² log N)            |
| N ≤ 5,000      | O(N²)                  |
| N ≤ 1,000,000  | O(N log N)             |
| N ≤ 10,000,000 | O(N)                   |
| 그 이상           | O(log N), O(1)         |

- 주의할 점으로는 프로그램 언어마다 처리 속도가 다르다는 점을 인지 (컴파일러 > 인터프리터)
---
## 정수와 실수 자료형

### 정수 자료형
자바 기준으로

 - `char`: 1 Byte = 8 bit



| idx | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|-----|---|---|---|---|---|---|---|---|
| val | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

### 🔹 Overflow (127 + 1 = -128) 

|  | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|--|---|---|---|---|---|---|---|---|
|127 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
|+1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
|sum | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

### 🔹 Underflow (-128 - 1 = 127) 
- 이진수의 뺼셈은 2의 보수(1의 보수 + 1)로 덧셈

|  | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|--|---|---|---|---|---|---|---|---|
|-128 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
|-1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
|sum | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

- `short`(2 byte), `int`(4 byte), `long`(8 byte) 도 동일하게 적용됨

### 예제 
1. char a = 0 ~ 128 for 문으로 순회하는 함수
2. 50! 를 61로 나눈 나머지를 반환하는 함수
3. 10**10 를 100000007 로 나눈 나머지를 반환하는 함수
---

### 실수 자료형

- **정규화**
  - 소수점 위치를 조정해서 1.xxxxxx × 2^n 꼴로 만드는 수학적 과정
  <br><br>
- **Floating Point**

  - 소수점의 위치가 "떠다니는(floating)" 숫자를 표현하는 방식


> ### **IEE 754 표준**<br>
> ![](/img/IEE%20754%20standard.png)



| 항목       | sign                        | exponent            | mantissa (fraction)                       |
|------------|-----------------------------|---------------------|--------------------------------------------|
| 설명       | 부호 비트 (0: 양수, 1: 음수) | 지수부 (2의 몇 제곱인지, bias 적용됨) | 유효 숫자의 소수 부분 (1.xxx 중 xxx 부분) |

- sign : 부호 
- exponent : 지수부
  - 표현 가능한 **숫자의 크기** 범위 결정
- mantissa : 가수부
  - **숫자의 정밀도 결정** 
    - mantissa 앞의 1 은 Hidden Bit 로 저장
    > mantissa 는 2진수로, 숫자의 정밀도를 의미함.  
      float 로 예를 들면, mantissa 가 23bit 이므로, 23개의 비트 만큼의 정밀도를 가졌다고 할 수 있다.
      <br>이걸 10진수 기준으로 이해하기 쉽게 바꾸려면 log₁₀(2^(23+1))을 계산해야 한다.  
      즉, 2^(23+1)이 정확히 몇인지는 몰라도, 그것이 10진수로 몇 자리 수인지 알고 싶다면<br>
      log₁₀(2^(23+1)) 을 계산하면 된다. ( 약 7.24 )<br>
    결국, float의 정밀도는 **10진수 기준 약 7자리** 정도까지 정확하다고 볼 수 있다.




| 타입   | 지수 비트 수 | bias (오프셋) |
|--------|--------------|---------------|
| float  | 8비트        | 127           |
| double | 11비트       | 1023          |

- **bias (오프셋)**
  - 지수에 일정 값을 더해서 음수도 양수처럼 보이게 저장하는 방식 
  - float 는 8 bit 로 0 ~ 258 중, 기준을 중간인 127 로 둠
    - 저장된 값이 127이면 실제 지수는 127 - 127 = 0
    - 저장된 값이 130이면 실제 지수는 +3
    - 저장된 값이 120이면 실제 지수는 -7
<br><br>

< 예시 > **실수 : 0.1 를 float 변수에 저장하는 과정** <BR>
> **2진수** : 0.00011001100110011001100... (무한 반복)<BR>
> **정규화** : 1.10011001100110011001101 × 2^(-4)<br>
> **IEEE 754 표현 수식**: (-1)^0 × 1.10011001100110011001101 × 2^(-4)

| sign | exponent | mantissa                                   |
|------|----------|--------------------------------------------|
| 0    | 127 - 4  | 10011001100110011001101 (23bit니까 23자리만 가져옴)|

**float 변수에 저장되는 값 => 0 1111011 10011001100110011001101**

---
**이와 같은 원리로 부동소수점의 아래 특징은 꼭 기억해야한다**
#### 🔸 1. 0.1 + 0.1 + 0.1 `!=` 0.3
  - `1/3` 은 무한 소수이고, 부동 소수점의 mantissa는 유한하게 저장
    - 따라서 **실수는 항상 근사값으로 저장되고 오차가 발생함**
    > 정밀도를 계산하는 로직은 항상 동일한데, <br>한번에 계산하는 것(double a = 0.4) 과<br> 
      여러번 계산하는 것 (double a = 0.2 + 0.2 ) 은 왜 일치하지 않을까
    
    > [!CAUTION]
    <br>**오차는 근사값 연산이 누적되어 발생한다.**  
    실수는 2진수로 완벽하게 표현되지 않는 경우가 많다.
- **오차가 허용되면 실수형 변수**를, **허용되지않으면 정수형 변수**를 사용


#### 🔸 2. `long` → `double` 변환 시 오차 발생

- `double`의 상대 오차는 약 `10^-15` 
  - 10진수 15자리 까지 정밀성 완정 보장
  - 이 말은 즉 정수부가 **15자리를 넘어가도 누락이 되기 시작**한다는 것
- 예를 들어 `10^18 + 1` 같은 큰 수를 `double`에 저장하면 마지막 `+1`이 무시되어 **정밀도가 깨짐**
- **정확한 값**이 필요한 경우 **long/int를 유지**해야 함**


### 🔸 3. 실수 비교 시 `==` 사용 금지

- `double`은 연산 시 오차가 발생하므로, **등호 비교는 위험**
- **대신 두 수의 차이**(EPSILON)가 작으면 같다고 판단
    - **EPSILON** : 두 수가 사실상 같다고 간주하기 위한 오차 범위
    - 값 하나만 저장하고 끝나면 오차가 없지만, 계산이 누적되면 오차가 발생할 수 있다
    - 뒤에서 부터 영향을 받기 때문에, 기업들 사이에서는 보통 10^-12를 EPSILON 으로 지정
# 마치며..
## 실무에서 금액계산, 정산 등에는 Big Decimal 쓴다
 